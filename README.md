# Python_strings
Задание на изучение строк

# Задача
- В качестве практической работы необходимо нарисовать блок-схемы работы алгоритма решения задач и загрузить в свой репозиторий в течение дня.
- В качестве домашней работы необходимо реализовать программы по ранее созданным алгоритмам решения задач на языке Python и загрузить в свой репозиторий до крайнего срока.

Даты сдачи оговариваются в канале группы.

**Для выполнения задания можно использовать обращение по индексу, регулярные выражения а также методы len(), encode() и decode()**

# Теоретическая справка
Строка в Python — последовательность символов (текст). В Python 3 тип str хранит текст в виде Unicode (не байты), т.е. строка может содержать буквы, эмодзи, символы любых языков.

## Как создавать литералы строк
* Можно в одинарных или двойных кавычках:
```
'a'         # одинарные
"hello"     # двойные
```

* Тоже самое — удобно, если в строке есть кавычки другого вида:
```
quote = "She said: 'Hi!'"
quote2 = 'He said: "Hi!"'
```

* Многострочные строки — тройные кавычки:
```
multiline = """Первая строка
Вторая строка
Третья строка"""
```

* Байтовые литералы (другой тип bytes):
```
b = b'hello'   # не str, а bytes; используется для работы с бинарными данными
```

## Экранирование (escape sequences) и raw-строки
Экранирование необходимо, когда мы должны определённым образом оформить строку, так у нас для этого существуют специальные символы и raw-строки:
### Специальные символы:
* **\n** - перевод на новую строку
* **\t** - табуляция
* **\\\\** - проставление бэкслеша
* **\\'** - проставление одинарной кавычки 
* **\\"** - проставление двойной кавычки

### Raw-строки:
raw-строки r"..." (не экранируют \, но не следует заканчивать raw-строку одиночным обратным слешем)
```
path = r"C:\Users\Name"
```

## Иммутабельность (неизменяемость)
Строки в Python неизменяемы. Любая операция, «изменяющая» строку, возвращает новую строку.

## Индексация и срезы
### Индексы:
нулевой — первый символ. Отрицательные индексы — с конца.
```
s = "Python"
s[0]    # 'P'
s[-1]   # 'n'
```

### Срезы: 
s[start:stop:step] — start включается, stop не включается.
```
s[1:4]    # 'yth'  (индексы 1,2,3)
s[:3]     # первые 3 символа
s[::2]    # каждый второй символ
s[::-1]   # строка в обратном порядке (реверс)
```

## Операции: конкатенация, повторение, проверка вхождения
```
"Hello, " + "world"    # конкатенация -> "Hello, world"
"ha" * 3               # -> "hahaha"
"py" in "python"       # True — проверка подпоследовательности
```
Конкатенация в цикле — медленнее, чем .join() для большого числа кусков.

## Перебор строк
Строку можно перебирать как последовательность символов:
```
for ch in "Привет":
    print(ch)
```

## Полезные методы str
* s.lower(), s.upper() — регистр
* s.strip(), s.lstrip(), s.rstrip() — убрать пробелы (или другие символы)
* s.split(sep=None, maxsplit=-1) — разбить в список (по пробелам по умолчанию)
* s.rsplit() — как split, но справа
* sep.join(iterable) — собрать из списка строк (более эффективно, чем += в цикле)
* s.replace(old, new, count=-1) — заменить подстроки
* s.find(sub), s.rfind(sub) — вернуть индекс или -1
* s.index(sub) — как find, но бросает ValueError, если не найдено
* s.count(sub) — количество вхождений
* s.startswith(prefix), s.endswith(suffix) — проверка начала/конца
* s.isalpha(), s.isdigit(), s.isalnum(), s.isspace() — проверки
* s.partition(sep) -> tuple (before, sep, after) — удобно для разбора одной разделённой части
* s.format(...) и f-строки (ниже про форматирование)

## Форматирование строк
### Старый стиль: % (используется редко сейчас)
```
"%s is %d years old" % ("Alice", 30)
```
### Метод format:
```
"{} + {} = {}".format(1, 2, 3)
"{name} is {age}".format(name="Bob", age=25)
```
### Современный и удобный — f-строки (начиная с Python 3.6):
```
name = "Anna"
age = 28
f"{name} is {age} years old"
f"{3.14159:.2f}"   # формат: округление (2 знака после десятичной)
f"{value:>10}"     # выравнивание по ширине
```

## Unicode и кодировки
str в Python — текст в Unicode. Для взаимодействия с файлами/сетью нужно кодировать в байты:
```
s = "Привет"
b = s.encode("utf-8")     # bytes
s2 = b.decode("utf-8")    # обратно в str
```

Частые кодировки: "utf-8" (рекомендуется), "latin-1", "cp1251" и т.д.

Если работаешь с внешними данными, всегда указывай кодировку при открытии файла:
```
with open("file.txt", "r", encoding="utf-8") as f:
    text = f.read()
```

**Замечание про символы и графемы:** некоторые видимые «символы» (например, буква + диакритика или эмодзи) могут состоять из нескольких Unicode-кодовых точек; len() считает кодовые точки, не «видимые символы».

## Байты vs строки
* str — текст (Unicode)
* bytes — байтовая последовательность (для файлов, сокетов, шифрования)

Нельзя смешивать без .encode()/.decode():
```
b = b'hello'
s = "hello"
# b + s  # TypeError
b + s.encode()  # ok
```

## Эффективность и практические советы
Для объединения многих кусочков текста используйте "separator".join(list_of_strings) вместо многократной +=.

Если нужно часто «изменять» текст, можно собирать список фрагментов и в конце join.

f-строки обычно быстрее и читаемее, чем format().

## Обработка сложных шаблонов и поиск — регулярные выражения
Для более сложных поисков/замен используйте модуль re:
```
import re
re.findall(r"\b\w+\b", text)   # найти все слова
re.sub(r"\s+", " ", text)      # заменить несколько пробелов одним
```
